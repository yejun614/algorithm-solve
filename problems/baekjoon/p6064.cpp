/*
 * (230201) 카잉 달력
 * https://www.acmicpc.net/problem/6064
 *
 * [풀이]
 * 수학문제로 고민 끝에 공식을 만들어 풀이하였다.
 * (문제 내용은 홈페이지 참고)
 *
 * 우선 문제에서 말하는 내용을 이해할 수 있어야 한다. 문제에서는 아주 특이한
 * 수 체계를 말하고 있는데 그 규칙은 아래와 같이 나타낼 수 있다.
 *
 * (M = 10, N = 12)
 * --+-----------------------------------------------------------------------------
 * i |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 
 * --+-----------------------------------------------------------------------------
 * x | 01 02 03 04 05 06 07 08 09 10 01 02 03 04 05 06 07 08 09 10 01 02 03 04 ...
 * y | 01 02 03 04 05 06 07 08 09 10 11 12 01 02 03 04 05 06 07 08 09 10 11 12 ...
 * --+-----------------------------------------------------------------------------
 * i = 10진수
 *
 * [1. 우선 <1:1>부터 <M:N>까지의 개수를 구해보자]
 * x와 y는 각각 M과 N크기로 반복되고 있다. <M:N>이 나오기 위해서는
 * M * count % N = 0를 만족하는 count 값을 구해야 한다. (count = 1, 2, 3 ...)
 *
 * [2. 문제에서 요구하는 <x:y>를 십진수로 바꾸었을 때 값을 구해보자]
 * <x:y>가 주어졌을 때 x가 언제 나타나는지 생각해 보면,
 * x가 M번에 한번씩 반복되기 때문에
 * x, (x + M), (x + (M * 2)), (x + (M * 3), ... 순으로 등장함을 알 수 있다.
 *
 * 정리하면 x' = x + (M * m) 으로 나타낼 수 있으며 m = 0, 1, 2, 3 ... 이다.
 *
 * 여기서 구한 x'와 대응되는 y' 중에서 문제에서 주어진 y가 있는지 확인해 보자.
 * y는 N번에 한번씩 반복되므로 x' 값에 N을 나눈 나머지가 y와 같다면
 * x'이 <x:y>가 가르키는 수 임을 알 수 있다.
 *
 * 마지막으로 예외 케이스 (e.g. <M:N>과 같은 경계선 케이스) 처리를 위해
 * 다음과 같이 공식을 정리 한다.
 * (x' - 1) mod N = y - 1 을 만족하는 x'이 <x:y>를 가르키는 수가 된다.
 *
 * [3. 과연 이 공식이 최선일까?]
 * 중국인의 나머지 정리를 확인해 보는걸 추천한다.
 */

#include <cstdio>

int solve(int M, int N, int x, int y) {
  if (x == y) return x;

  int count = 1;
  while (M * count % N != 0) ++count;

  const int total = M * count;
  for (int i = x; i <= total; i += M) {
    if ((i - 1) % N == y - 1) return i;
  }

  return -1;
}

int main() {
  int T;
  scanf("%d", &T);

  int M, N, x, y;
  while (T--) {
    scanf("%d %d %d %d", &M, &N, &x, &y);
    printf("%d\n", solve(M, N, x, y));
  }

  return 0;
}

